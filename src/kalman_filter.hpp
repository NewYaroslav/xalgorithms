#ifndef KALMAN_FILTER_HPP_INCLUDED
#define KALMAN_FILTER_HPP_INCLUDED

/** \brief Одномерный фильтр Калмана
 * Оригинал статьи: https://habr.com/post/140274/
 * F — переменная описывающая динамику системы,
 * в случае с топливом — это может быть коэффициент определяющий расход топлива на холостых оборотах за время дискретизации (время между шагами алгоритма).
 * Однако помимо расхода топлива, существуют ещё и заправки…
 * поэтому для простоты примем эту переменную равную 1 (то есть мы указываем, что предсказываемое значение будет равно предыдущему состоянию).
 * B — переменная определяющая применение управляющего воздействия.
 * Если бы у нас были дополнительная информация об оборотах двигателя или степени нажатия на педаль акселератора,
 * то этот параметр бы определял как изменится расход топлива за время дискретизации.
 * Так как управляющих воздействий в нашей модели нет (нет информации о них), то принимаем B = 0.
 * H — матрица определяющая отношение между измерениями и состоянием системы, пока без объяснений примем эту переменную также равную 1.
 * Определение сглаживающих свойств:
 * R — ошибка измерения может быть определена испытанием измерительных приборов и определением погрешности их измерения.
 * Q — определение шума процесса является более сложной задачей, так как требуется определить дисперсию процесса, что не всегда возможно.
 * В любом случае, можно подобрать этот параметр для обеспечения требуемого уровня фильтрации.
 */
template <typename T>
class xaKalmanFilterSimple1D {
private:
    T X0; /**< предсказанное состояние */
    T P0; /**< предсказанная ковариация */

    T F; /**< коэффициент реальной стоимости к предыдущей реальной стоимости */
    T Q; /**< измерительный шум */
    T H; /**< коэффициент от измеренной величины до реальной величины */
    T R; /**< шум окружающей среды */

    T State;
    T Covariance;
public:
    xaKalmanFilterSimple1D(T q, T r, T f = 1, T h = 1) {
        Q = q;
        R = r;
        F = f;
        H = h;
    }

    inline void set_state(T state, T covariance) {
        State = state;
        Covariance = covariance;
    }

    inline T updata(T data) {
        //время обновления - предсказание
        X0 = F*State;
        P0 = F*Covariance*F + Q;

        //обновление измерений - коррекция
        T K = H*P0/(H*P0*H + R);
        State = X0 + K*(data - H*X0);
        Covariance = (1 - K*H)*P0;
        return State;
    }
};

#endif // KALMAN_FILTER_HPP_INCLUDED
